### 作用域和闭包

> 在ES5中，js的代码没有代码块，使用函数运行的机制进行创建闭包，闭包就是作用域的意思。在ES5中，js中只有函数才可以创建能操作的作用域。

> js中内存分为栈内存和堆内存；栈内存存储对象的地址，堆内存存储对象的具体内容；对于原始类型值存储在栈内存中，而基于引用类型值存储在堆内存中。
>
> 栈内存和堆内存的区别：栈内存运行效率高，但空间小；堆内存运行效率低，但空间大。所以构造简单的原始类型值放在栈内存中，构造复杂的引用类型值放在堆内存中而不影响栈的效率。

### 函数执行时形成私有作用域

> 函数在执行的时候，会形成一个私有的作用域（栈内存），供函数代码的执行；
>
> - 形参赋值
> - 私有作用域下的预解释（变量提升）
> - 私有作用域下的代码执行
>
> 闭包：形成的新的私有作用域还保护了私有变量不受外界的影响，我们把函数的这种保护机制叫“闭包”。
>
> 为什么要有作用域？  因为变量哟啊规定活动范围的，为便于管理不同范围的变量，所以要给变量设置活动范围。

```js
function fn(){
    var a = 1;
}
fn();
fn();
console.log(a);//=>Uncaught ReferenceError: a is not defined
```

> 上面的fn运行了两次，所以产生了两个堆内存，也就是两个作用域（作用域也就是闭包）各自分别有一个a的变量；a的值都是数字1，但是两个变量是不相等的，两个a之间没有任何关系。

### 全局变量和私有变量

> 在全局作用域下声明的变量是全局变量
>
> 在私有作用域下声明的变量是私有变量；函数的形参也是私有变量；

### 如何区分函数中出现的变量是私有的还是非私有的？

> 首先判断变量是否为形参，若是，则该变量是私有变量；
>
> 然后判断变量是否在作用域中声明过，（有没有var过），若是，则该变量是私有变量；
>
> 否则，不是私有变量。会向上级作用域查找，上级没有则继续查找，一直找到window为止。
>
> 如果window也没有，该操作是获取该变量，则会报错。

```js
function fn(){
    console.log(num);//Uncaught ReferenceError: num is not defined
}
fn();
```

> 在没找到该变量时，如果该操作是设置变量，则会给全局作用域加一个

```js
function fn(){
    num = 12;//相当于给window增加了一个叫做num的属性名，属性值是12 window.num = 12;
}
fn();
console.log(num);//12
```

### 如何查找当前作用域的上级作用域？

> 当前作用域的上级作用域是谁和函数执行的没有任何关系，我们只需要看当前函数时在哪个作用域下定义的，那么上级作用域就是谁。

```js
var total = 100;
function fn (){
    var total = 10;
	return function(){
        console.log(total);
    }
}
var f = fn();//f = xxxfff111
f();//=>10 因为f是在fn的作用域下定义的，所以f的上级作用域就是fn执行时开辟的私有作用域
```

```js
var a=0;
var b="0";
function fn(){
    console.log(a);
　　console.log(b);
　　console.log(typeof a);
    console.log(typeof b);
　　a="1";
　　var b=1;
　　console.log(a);
　　console.log(b);
　　console.log(typeof a);
　　console.log(typeof b);
}
fn();
```

![](D:\js学习\js基础\img\查找上级作用域例子.png)

> 预解释是作用域中的预解释；js例是可以函数里面嵌套函数的；都运行的时候，是在函数创建的作用域例在创建一个作用域

**js代码的执行顺序:**

> js中代码的执行顺序是从上自下逐条执行的；
>
> 遇到function定义的代码块，直接跳过；
>
> 遇到函数执行的代码，就找到引用的函数地址，开始跳到执行函数产生的作用域中执行代码。
>
> 函数执行完后，再回到当前作用域下执行下面的代码。

**作用域链查找**

> 当作用域套作用域的时候，若children中找不到某个变量，则会到children的父作用域father中找；
>
> 当father中找不到的时候，这会到father的父作用域中查找，一直找到window这个根作用域。

### JavaScript中的顶级作用域是谁？

> 顶级作用域是Global
>
> 目前只有node.js这个语言可以访问到global；node.js中是进程，叫process，后台编程中不管浏览器的事，node中是global，js中只可以访问到window
>
> window相当于global的代理人；一般在js中的全局变量都是window；全局变量就是window的属性；通过window.varName可以访问到；
>
> 但并不是所有的都属于window的，如：Object，Math，String，Function等这6个包装类，就不属于window的属性，和window是无关的。
>
> window只是前段编程例的顶级作用域。

### 变量和属性的关系

> 全局变量是window的属性，window的属性也可以看作是全局变量；
>
> 一个对象的属性，也可以看做以这个对象为作用域下的变量with语句；with(){}语句内即使用var来定义变量，也会冒泡到上一级作用域中，不推荐使用。

### 函数运行时产生的作用域

> 函数的运行是一个有生命周期的内存地址。
>
> 函数运行时，会创建一个内存地址，当此函数运行结束后，此内存地址又会被销毁；（这个地址，我们无法保存，它是灵活的，活动的，有生命周期的。我们也没有办法给这个作用域起一个变量名字，也无法保存这个作用域。）
>
> 也就是说，在作用域外无法控制作用域内部的数据，只能在作用域内部控制，而且作用域内部的代码可以控制外部的数据，这种机制叫做闭包，闭包也作用域链和函数的运行是有关系的。
>
> 函数里的变量，在这个内存里创建，我们可以把这个内存当做一个对象，那函数里的变量就是这个内存对象的属性；
>
> 函数的定义和函数的执行时两码事（fn和fn()的区别）

### 闭包

> 闭包是指有权访问另一个函数作用域中的变量的函数。
>
> 特点：
>
> - 可以在函数的外部访问到函数内部的局部变量
> - 让这些变量始终保存到内存中，不会随着函数的结束而自动销毁。

> 作用域就是闭包，作用域是函数定义的时候决定的，而不是函数调用的时候决定的
>
> 闭包是一种机制，并不是某种形式或者概念，最大的闭包就是window，我们可以把window当做一个闭包。
>
> 高程三解释：当在函数内部定义了其他函数时，就创建了闭包；闭包有权访问包含函数内部的所有变量；（其实只要函数运行了，就形成了封闭的作用域，就是闭包了）

### 作用域不销毁的情况|内存释放

> 当私有作用域中的部分内存被作用域以外的东西占着，那么当前作用域不销毁。
>
> - 当函数内return一个引用数据类型，并且函数外面有一个变量接收这个引用数据类型，则此时的作用域不销毁；
>
>   ```js
>   function fn(){
>       var num = 100;
>       return function(){   
>       }
>   }
>   var f = fn();//fn执行形成的这个私有作用域就不能再销毁
>   ```
>
> - 在一个私有作用域中给Dom元素的事件绑定方法，一般情况下我们的私有作用域不销毁
>
>   ```js
>   var oDiv = document.getElementById("div1");
>   ~function(){
>       oDiw.onclick = function(){}
>   }();//当前自执行函数形成的这个私有作用域也不能销毁
>   ```
>
> - 下述情况不立即销毁->fn返回的函数没有被其他的东西占用，但是还需要在执行一次，所以暂时不销毁，浏览器会在空闲的时候销毁‘
>
>   ```js
>   function fn(){
>       var num = 100;
>       return function(){}
>   }
>   fn()();//首先执行fn，返回一个小函数对应的内存地址，再让小函数执行
>   ```
>

![私有作用域](D:\js学习\js基础\img\私有作用域.png)

**堆内存**

> 对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存，堆内存有一个引用的地址，如果外面有变量等指到了这个地址，我们守这个内存被占用了，就不能销毁了。

> 【谷歌】：浏览器每隔一段时间，看我们的堆内存是否还有其他东西引用着，如果还被占用着，浏览器不会进行处理；如果未被占用，则会把这个堆内存进行回收释放
>
> 【IE、火狐】：开辟了一个堆内存，我们有一个占用的时候去，浏览器记一个数（记录有多少个占用内存），当我们减少引用时，浏览器会把记数减1，当记的数字减为0时，浏览器则会把堆内存回收释放

> 堆内存释放问题：是用来存储引用数据类型值的
>
> 栈内存释放问题：是用来提供js代码执行环境的

**手动释放堆内存**

> 对于堆内存的释放，我们再js代码编写的时候，对于没有用的堆内存，手动赋值为null，来取消对这个堆内存的占用，这样浏览器就可以吧没有被占用的堆内存进行回收释放。

















