### 代码写完后进一步优化

> HTTP相关优化：
>
> - 减少HTTP请求次数和请求大小
>
> - CDN加速
> - 304缓存
>
> 代码优化：
>
> - 有利于SEO
>
>   （ 页面中不要出现无效的链接、提高关键字曝光率、img需要加alt、设置meta标签、标签语义化...）（重量级SEO优化：直接服务器端渲染，还有一个好处就是页面的加载速度比客户端更快）
>
> - 有利于扩展维护
>
> - 有利于减少性能消耗
>
> 
>
> 图片懒加载
>
> 异步编程和延迟分批加载
>
> 基于JSON格式传输数据
>
> 减少cookie的使用
>
> JS封装
>
> 尽量减少闭包的使用
>
> 合并JS、CSS
>
> 使用字体图标和SVG图标
>
> 减少DOM操作
>
> 使用事件委托
>
> 减少递归的使用
>
> 
>
> 合理使用defer和async
>
> 设置音视频标签使用preload="none"
>
> localstorage本地存储 / manifast离线存储
>
> 避免使用iframe
>
> 
>
> CSS雪碧图
>
> 少用标签选选择器
>
> 少用@import
>
> 少用filter
>
> 避免使用css表达式
>
> 
>
> css放在body上，js放在body下
>
> 能用css，就不用js
>
> 减少eval的使用
>
> 多使用设计模式
>
> 

```
【JS性能优化】
. 做CDN加速（重量级优化）（非常烧钱）

. 利用浏览器和服务器端的缓存技术（304缓存），把一些不经常更新的静态资源文件做缓存处理（例如：JS、CSS、静态图片等都可以做缓存）（减少HTTP请求的大小）

. 采用图片的“懒加载”（延迟加载）
	目的是为了减少页面第一次加载过程中HTTP请求的次数
	
. 页面中的数据获取采取异步编程和延迟分批加载
	因为异步获取数据，降低HTTP通道的堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度（需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后让其显示）
	延迟分批加载类似于图片的懒加载，是为了减少第一次页面加载时候HTTP的请求次数
	
. 在前后端交互的时候，对于多项数据我们尽可能基于JSON格式来进行传送（JSON格式的数据处理方便，资源偏小）=>相对于XML格式的传输才会有这个优势

. 减少对于cookie的使用（最主要的是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端传来传去

. 尽可能实现JS封装（低耦合高内聚），减少页面中的冗余代码（减少HTTP请求资源的大小）

. 在JS中尽量减少闭包的使用（原因：闭包会产生不释放的栈内存）
	A：循环给元素做事件绑定的时候，尽可能把后期需要的信息存储到元素的自定义属性上，而不是闭包存储
	B：可以在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建闭包（例如单例模式）
	C：尽可能手动释放不被占用的内存
	...
	
. 尽量合并CSS和JS文件（把需要引入的CSS合并为一个，JS也是合并为一个），原理是在减少HTTP请求的次数，尽可能的把合并后的代码进行压缩，减小HTTP请求资源的大小
	A：webpack这种自动化构建工具，可以帮我们实现代码的合并和压缩（工程haul开发）
	B：在移动开发（或者追求高性能的PC端开发\例如百度首页）中，如果CSS或者JS不是需要很多，我们可以选择把CSS和JS编程内嵌式

. 尽量使用字体图标或者SVG图标，来代替传统的png等格式的图片（因为字体图标等是矢量图（基于代码编写出来的），放大不会变形，渲染速度快，相对比位图要小一些）

. 减少DOM的操作（主要是减少DOM的重绘和回流）
	A：关于重排和分离读写
	B：使用文档碎片或者字符串拼接的方式做数据绑定（DOM的动态创建）

. 尽可能使用事件委托（事件代理）来处理事件绑定的操作，减少DOM的频繁操作，其中包括给每一个DOM元素做事件绑定



在JS中因当避免“嵌套循环”和“死循环”
减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套（建议使用尾递归）

【HTML优化】
. 基于script调取JS的时候，可以使用defer或者async来异步加载（defer是延迟加载js脚本文件（延迟到DOM加载完成），async是异步加载js脚本文件）

. 页面中出现音视频标签，我们不让页面加载的时候就去加载这些资源（要不然页面加载速度就会变慢）（方案：只需要设置preload='none'即可），等待页面加载完成，音视频播放的时候我们再去加载音视频

. 利用H5中提供的localstorage本地存储或者manifest离线缓存，做一些信息的本地存储，下一次加载页面的时候直接从本地获取，减少HTTP请求次数

. 避免使用iframe标签（不仅不好管控样式，而且相当于在A页面加载了其他页面，消耗性能较大）

【CSS性能优化】
. 尽量减少对标签选择器的使用（因为CSS选择器解析规则是从右向左解析的）
	.container .link a{
		先找到所有的a标签，再筛选.link下的a标签...
		找所有的a标签是非常耗新能的
	}
	
. 在CSS导入的时候尽量减少@import导入式，（因为@import是同步操作，只用把这个对应的CSS导入，才会向下架子啊，而link是异步操作）

. 学会使用CSS雪碧图（css sprite / css 图片精灵）
	把所有相对较小的资源图片汇总到一张大图上，后期只需要把大图加载下来，用背景定位的方式展示对应的小图即可（使用样式类保存大图，这样可以只加载一次）
	.bg {
		background:url('./xxx.png');
	}
	.box1{
		background-position:...
	}
	.box2{
		background-position:...
	}
	<div class = 'bg box1'></div>
	
. CSS中设置定位后，最好使用z—Index改变盒子层级，让所有盒子不在相同的平面上，这样处理后，性能有一丢丢提高

. 尽量减少对于filter滤镜属性的使用（这个属性消耗性能较大一些）

. 尽量减少CSS表达式（在CSS中使用expression等等）的使用
	


额外技巧：
1. 我们一般吧CSS放到BODY上面，JS放到BODY下面
2. 能用CSS搞定的绝对不用JS，能用JS搞定的绝对不用插件（应为CSS处理动画等功能性能优于JS，而且CSS的transform变形还开启了硬件加速）
3. 减少eval的使用（因为JS合并压缩的时候，可能会出现由于符号不完善，导致的代码执行优先级错乱的问题）
4. 尽量使用设计模式（单例、发布订阅、构造、Promise）来管理我们的代码，方便我们后期的升级和维护
5. 页面中不要出现无效的链接（利于SEO优化），还有其他技巧：提高关键字曝光率、img需要加alt、设置meta标签、标签语义化...
```





2. 代码存在的隐性问题

   - 在瀑布流案例中，完成获取到数据后，在实现绑定页面时，由于需求，每次获取3个数据，但是，这就存在了获取到的数据为undefined的情况，因此要**设置默认值为空**

     ```js
     let item = imgData[i + index] || '';
     ```

   - 在瀑布流案例中，在滚动事件触发时，由于满足条件，一个操作（queryData / bindHTML）会执行n次，因此我们需要做**“重复操作限定”**

     ```js
     //设置isRun：表示是否完成获取数据和数据绑定；true：表示完成了，不需要再执行了；false：表示没有完成，需要执行
     let isRun = false;//初始的获取数据和数据绑定为false
     let bindHTML = ()=>{
         isRun = false;//下一次的获取数据和数据绑定为false
     }
     $(window).on('scroll', () => {
         if ((winH + scrollT + 100) >= pageH) {
             if (isRun) {//如果本次获取数据和数据绑定位true，则return。
                 return;
             }
             isRun = true;//当满足条件时，本次获取数据和数据绑定为true
             queryData();
             bindHTML();
         }
     });
     
     
     
     ```


4. 在函数内若一个形参是个对象，而我们需要获取对象的属性值，可以使用对象的解构赋值

```js
productData.forEach(({
    price,
    time,
    hot,
    img = 'img/1.png',
    title
}) => {
    str += `<li data-price="${price}" data-time="${time}"  data-hot="${hot}">
<a href="#">
<img src="${img}" alt="">
<p title="${title}">${title}</p>
<span>$${price}</span>
<span>时间：${time}</span>
<span>热度：${hot}</span>
</a>
</li>`;
});
```

5. 在使用$()创建JQ实例的时候，若需要多次引用同样的实例，则先声明$xxx变量，然后直接使用$this即可，这样可以避免多次创建同样的实例

```js
$('.box > li').on('click',function(){
    let $this = $(this);
    let obj = {
        index:$this.index()+1,
        name:$this.text(),
        link:$this.attr('href');
    };    
});
```

6. 当函数不传递参数时，要考虑他的默认值情况

```js
callback = new Function('');//回调函数不传参默认为函数
obj = {};//默认为空对象
event = event || window.event;
...
```

7. 当使用for—in循环遍历对象时，需要添加判断条件

```js
for (let attr in obj) {
    if (obj.hasOwnProperty(attr)) {
    }
}
```

8. 图片的延迟加载（图片的懒加载）

> 图片的延迟加载是前端优化的重要手段之一，开始加载页面的时候，并没有真实的图片，当页面结构和数据都呈现完成后，在加载真实的图片
>
> 步骤：
>
> 1. 在结构上，我们把img图片放到div盒子中，开始的时候图片的src为空，我们就把图片的地址存放到自定义属性 data-src中，我们给图片所在的盒子设置一个默认的背景图片占位（要求这张图越小越好 1KB）
>
> 2. 在JS中，当监听到页面中的结构和数据都加载完成后（或者设置一个间隔时间），开始把data-src自定义属性中存储的真实图片地址赋值给img的src属性
>
>    =>为了防止图片地址不存在导致的404错误，我们在赋值图片的src属性时，往往都会验证一下图片是否存在
>
> **多张图片的延时加载**
>
> - 获取数据
> - 数据绑定到HTML中
> - 加载真实图片
>   - window页面加载完成或滚动时计算哪张图片可以加载
>   - 加载单张图片
>   - 优化：图片加载之后，防止图片的再次加载，需要“重复操作限定”
