### 垃圾回收机制

> JavaScript具有垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
>
> **原理：垃圾收集器在固定的时间间隔，周期性地释放那些不再继续使用的变量。**
>
> 关于局部变量：
>
> - 局部变量只有在函数执行的过程中存在。在函数执行的过程中，会为局部变量分配堆栈内存空间来存储它们的值，然后在函数中使用，直到函数执行结束；
> - 此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。这种情况下很容易判断出变量是否嗨哟就存在的必要；
> - 但并非所有情况都能很容易地知道该变量是否有存在必要。因此垃圾收集器必须跟踪哪个量有用哪个变量没用，对于没用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略;**标记清除**和**引用计数**。

### 标记清除

> JavaScript中常用的垃圾收集方式是：标记清除。
>
> - 当变量进入环境时（例如：在函数中声明一个变量），就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
> - 而当变量离开环境时，则将其标记为“离开环境”。
>
> 可以使用任何方式来标记变量。（如：使用一个“进入环境”的变量列表及一个“离开环境”的变量列表来跟踪哪个变量发生了变化。）
>
> 如何标记变量并不重要，关键在于采取什么策略。
>
> **工作流程：**
>
> - 垃圾收集器在运行的时候会给存储在内存中的变量都加上标记（当然，可以使用任何标记方式）。
> - 它会去掉环境中的变量以及被环境中的变量引用的变量的标记。
> - 在此之后再被加上的标记的变量将被视为准备删除的变量（因为环境中的变量已经无法访问到这些变量）。
> - 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并且回收它们所占用的内存空间。

### 引用计数

> 跟踪记录每个值被引用的次数
>
> **工作流程**：
>
> - 当声明一个变量并将一个引用类型值赋给该变量时，则这个引用类型值的引用次数就是1；
>
> - 如果同一个值又赋给另一个变量，则该值的引用次数加1；
> - 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1；
> - 当这个值的引用次数变为0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
> - 这样，当垃圾收集器下次再运行时，他就会释放那些引用单词书为零的值所占用的内存。

> 这种方式有一个严重的问题；循环引用；
>
> 循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。
>
> ```js
> function problem(){
>     var objectA = new Object();
>     var objectB = new Object();
>     objectA.someOtherObject = objectB;
>     objectB.anotherObject = objectA;
> }
> ```
>
> > - objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除的策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。
> >
> > - 但是在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还将将继续存在，因为他们的引用次数永远不会是0；
> > - 假如这个函数被多次重复调用，就会导致大量内存得不到回收。
>
> 解决：手工断开js对象和DOM之间的链接。赋值为null。IE9把DOM和BOM转换成真正的JS对象了，所以避免了这个问题。

### 性能问题

>  垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很客观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

> IE的垃圾收集器是根据内存分配量运行的，存在的问题在于分配量就那么多，垃圾收集器不得不频繁的运行，导致性能极低。IE7的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：**触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正**。IE7 中的各项临界值在初始时与 IE6 相等。
>
> - 如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。
> - 如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。

### 开发过程中怎样管理内存

> 使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。**内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。**
>
> **因此确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放引用——这个做法叫引用解除**
>
> **这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动解除引用；**
>
> ```js
> function createPerson(name){
>     var localPerson = new Object();
>     localPerson.name = name;
>     return localPerson;
> }
> var globalPerson = createPerson("Nicholas");
> //手工解除globalPerson的引用
> globalPerson = null;
> ```
>
> > 在这个例子中，变量 globalPerson 取得了 createPerson() 函数返回的值。在 createPerson()函数内部，我们创建了一个对象并将其赋给局部变量 localPerson ，然后又为该对象添加了一个名为name 的属性。最后，当调用这个函数时， localPerson 以函数值的形式返回并赋给全局变量globalPerson 。
> >
> > 由于 localPerson 在 createPerson() 函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。
> >
> > 但是对于全局变量 globalPerson 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。
>
> **解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正目的是为了让垃圾回收器在下一次运行的时候将其回收**
>
> **解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。**





























































